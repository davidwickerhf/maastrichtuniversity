# Exam Prep - Objects in Programming - 14/12/2023

# Table of Content

* * *

  

# **Agenda**

* * *

## **Schedule**

*   Past Papers - 1 Hour
*   Break - 15 Minutes (?)
*   Break - 15 Minutes (?)
*   Q&A - 30 Minutes

  

## **Links**

### Exams

[Preparation-Exam-2021.pdf](https://t9015002824.p.clickup-attachments.com/t9015002824/ca9978cf-fcd9-4f7a-a78c-8cabb4c3ec8b/Preparation-Exam-2021.pdf)

[Preparation-Exam-2021-Answers.pdf](https://t9015002824.p.clickup-attachments.com/t9015002824/515f97c7-980f-4338-98a3-f240aa1d259f/Preparation-Exam-2021-Answers.pdf)

[Exam Prep - Objects in Programming.zip](https://t9015002824.p.clickup-attachments.com/t9015002824/62e4bf2a-602c-41f6-8cd0-f82be44dbb71/Exam%20Prep%20-%20Objects%20in%20Programming.zip)

  

## **Random**

*   _Do not click here_
    
    *   Fable is a beautiful game with a great [soundtrack](https://open.spotify.com/track/09m0mFvXJrDDMy1eJk3dhK?si=f065543ac9bb44ec)
        *   Oh and this [one](https://open.spotify.com/track/5qiS0uWgrWMRGvwAS93mpx?si=3a4a849b9f044683)
    *   It gave me inspiration to prepare this document
    *   BRO I LOVE [SKYRIM](https://open.spotify.com/track/0lmT9W6HJBuHTTLAx55CEI?si=833227b207204091) SO MUCH
        *   Like I'm writing this and I'm just imagining myself in a tavern and life is good. On a merry adventure to slay a dragon
    *   And everything [Ori and the Blind Forest](https://open.spotify.com/track/2zRITpQkUmaRwfIC2dsCIC?si=3e4ac0a884a64a06)
    *   Lord of the Rings is [GOATED](https://youtu.be/68-rToI63FM)
    *   [BANGER](https://www.youtube.com/watch?v=dQw4w9WgXcQ)
    *   Love you all <3
    

  

# **Past Paper**

* * *

*   _Instructions_
    
    *   _Text coloured in green are the correct answers_
    *   _Anything written in italics are comments by me_
    

## Question 1

### Answer

```plain
public class Rectangle
{
    private double x;
    private double y;
    private double width;
    private double length;

    public Rectangle(double x, double y, double width, double length)
    {
        this.x = x;
        this.y = y;

        this.width = width;
        this.length = length;
    }

    public void translate(double deltaX, double deltaY)
    {
        x += deltaX;
        y += deltaY;
    }

    public boolean contains(double coordX, double coordY)
    {
        return (coordX >= x) && (coordX <= x + length) && (coordY >= y) && (coordY <= y + width);
    }
}
```

###   

## Question 2

1. **All methods in an interface must be declared public**
    1. **True**
        1. _Other language allow different modifiers but Java requires_ **_all_** _methods in an interface to be public_
        2. _The reason Java requires this is that if the method was not public then the class implementing the interface would not have access to the method on the interface. Since only public methods can be accessed from outside the class or interface_
2. **When casting object types you take a risk of causing an exception**
    1. **True**
        1. _When you cast an object of one type to another type you are essentially converting it from type A to type B but that does not mean that it can be converted._
        2. _I.e. cannot automatically convert a number into a boolean._
        3. _The compiler cannot check for all casting errors so you have a risk of the conversion failing and causing an exception_
3. **When the compiler encounters one class inside another class, it generates an error**
    1. **False**
        1. _You can safely create a class inside another class without any errors. This is called Nesting._
        2. _Mostly for organizational benefit_
        3. _Often you would only do this if the nested class only makes sense in the context of the parent class._
        4. _The nested class would not take up a file and would reduce the amount of files in your codebase_
        5. _The nested class's name can be reused elsewhere_
            1. _See:_[](https://app.clickup.com/9015002824/v/dc/8cnc1p8-5315/8cnc1p8-8435?block=block-97943b66-1fe0-4af9-8c96-003f3a2eb08d)
4. **Static methods cannot be included in an interface**
    1. **False**
        1. _They can be included and are really cool, but seldomly used_
        2. _Static interface methods require a body_
        3. _The class that implements the interface does not need to declare the static interface method_
        4. _They are useful if you want all classes that implement the interface to have a default way of executing a method_
5. **A non-static nested class cannot be instantiated without having creating an object of the outer class**
    1. **True**
        1. _This is just in Java and this is dumb_
        2. _See_ [](https://app.clickup.com/9015002824/v/dc/8cnc1p8-5315/8cnc1p8-8435?block=block-97943b66-1fe0-4af9-8c96-003f3a2eb08d)_in School's Main method for an example of instantiating a nested class from outside its parent class_

  

### Nested Classes Example

```java
public class School
{
    public static void main(String[] args)
    {
        // Answer for Statement: When the compiler encounters one class inside another class, it generates an error
        Student andrej = new Student("Andrej", 0);
        Student lisa = new Student("Lisa", 1);

        Teacher oti = new Teacher("Oti", -100);
        Teacher martijn = new Teacher("Martijn", 0000000);

        System.out.println(andrej);
        System.out.println(lisa);

        System.out.println(oti);
        System.out.println(martijn);

        // Answer for Statement: A non-static nested class cannot be instantiated without       having creating an object of the outer class.
        // Java is dumb
        Student.Data = andrej.new Data("Hello", 0);
    }
}

---
public class Teacher
{
    public class Data
    {
        private String name;
        private float salary;

        public Data(String name, float salary)
        {
            this.name = name;
            this.salary = salary;
        }
    }

    private Data data;

    public Teacher(String name, float salary)
    {
        data = new Data(name, salary);
    }

    @Override
    public String toString()
    {
        return "Teacher Name: " + data.name + " | Teacher Salary: " + data.salary;
    }
}

---
public class Student
{
    public class Data
    {
        private String name;
        private int id;

        public Data(String name, int id)
        {
            this.name = name;
            this.id = id;
        }
    }

    private Data data;

    public Student(String name, int id)
    {
        data = new Data(name, id);
    }

    @Override
    public String toString()
    {
        return "Student Name: " + data.name + " | Student ID: " + data.id;
    }
}
```

###   

## Question 3

**Explain when you might want to use an inner class**

1. The inner class has sense only in the context of the outer class.
2. I need direct access to the instance and static fields of the outer class
    1. I.e. Access without running usual accessor methods
        1. _Since the nested class is located in the parent class. Accessing the nested class from the parent class is faster_
        2. _This is unnecessary to know so you can just ignore it_

  

## Question 4

### Thoughts

1. _There are 2 types of casting:_
    1. _Implicit_
        1. _When the compiler can automatically convert the object from one type to another_
        2. _An object can only be implicitly cast if it will always be able to convert the objects without any errors_
        3. _I.e. A class B inherits from A. Class B can be implicitly casted to A since it will_ **_always_** _inherits from class A. You can guarantee all B's are A's_
    2. _Explicit_
        1. _When you manually cast the object from one type to another_
        2. _You will need to explicitly cast an object of one type to another type when there is a chance that the objects might not be convertible._
        3. _I.e. A class B inherits from A. Class A must be explicitly to B since there might be a Class C that might also inherit from A so you cannot guarantee that all A's are B's_
2. _If an object inherits or implements from a class or interface then that object is implicitly (automatically converted when needed) casted to that base type._
3. _However, if an object inherits or implements a class or interface and you want to cast the base class or interface to the object type then you need to explicitly cast it since its not guaranteed that it inherits or implements_

  

## Question 5

### Thoughts

1. _I think this answer was weird because its labelled as Inheritance but its just a recursive error_
2. _I think they were meant to say_ _`super.deposit(amount)`_
3. Super
    1. Super just means this class's parent class or interface (where ever that method came from)
    2. Saying `super.deposit(amount)` just means call the deposit method on this parent class

  

## Question 6

### Thoughts

1. Class `Counter` has a static variable for its value. This means all objects of type `Counter` share the **exact same** variable for `value`
2. It doesn't matter what object or class (as long as it derives from `Counter` ) their `value` is the same

  

## Question 7

```java
import javax.swing.*;

public class MouseFrame2
{
    public static void main(String[] args)
    {
        MouseComponent2 comp = new MouseComponent2();
        JFrame frame = new JFrame();

        frame.add(comp);
        frame.setSize(500, 500);
        frame.setVisible(true);
    }
}

---
import javax.swing.*;
import java.awt.Graphics;
import java.awt.event.*;
import java.awt.Graphics2D;

public class MouseComponent2 extends JComponent
{
    private int x = 20, y = 20;

    // Nested Class since it only makes sense in the context of MouseComponent. (Not needed, you can put this in its own file)
    // Implementing MouseListener allows you to listen to Mouse Events, in Java Swing, such as the Click
    public class MousePressListener implements MouseListener
    {
        public void mousePressed(MouseEvent event)
        { 
            // Stores the mouse's position in a global variable so that the x and y values can be used in the repaint method
            x = event.getX();
            y = event.getY();

            // Repaint calls the paintComponent method. Part of Java swing
            repaint();
        }

        // These are methods we are forced to implement by MouseListener
        // But we do not need to do anything with them for this task so we can leave the methods empty
        @Override
        public void mouseReleased(MouseEvent event) {}

        @Override
        public void mouseClicked(MouseEvent event) {}

        @Override
        public void mouseEntered(MouseEvent event) {}

        @Override
        public void mouseExited(MouseEvent event) {}
    }

    public MouseComponent2()
    {
        MouseListener listener = new MousePressListener();

        // Method in the JComponent class, requires a MouseListener as a parameter
        // We add our own custom MousePressListener since we wanted our x and y global variables to change values based on the click
        addMouseListener(listener);
    }

    // Method in the JComponent class. Called when the GUI is painted or repainted
    // This is generally how you would draw stuff on the GUI since it provides you with the Graphics that you need to draw on
    @Override
    public void paintComponent(Graphics g)
    {
        // This line is not necessary but makes it look 'prettier' since Graphics is very old and Graphics2D is 'newer' (Still old)
        Graphics2D g2 = (Graphics2D)g;

        // Draws a string at our x and y location
        // x and y values are set in the MousePressListener
        g2.drawString("DKE", x, y);
    }
}
```

  

## Question 8

```java
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JTextField;
import javax.swing.JButton;
import javax.swing.JPanel;
import java.awt.GridLayout;
import java.awt.BorderLayout;

public class MyFrame
{ 
    public static void main(String[] args)
    { 
        // P.S Some of this stuff is just intuitive and self explanatory and feels weird to write comments for
        // But its Java Swing and we don't like Java Swing

        // Create Labels
        JLabel a = new JLabel("AAAAAAAAAAA");
        JLabel b = new JLabel("BBBBBBBBBBB");
        JLabel c = new JLabel("CCCCCCCCCCC");

        // Create Text Fields
        JTextField e = new JTextField(10);
        JTextField f = new JTextField(10);
        JTextField g = new JTextField(10);

        // Create new Panel
        JPanel centerPanel = new JPanel();

        // Set the Layout of the Panel (Grid Layout which makes it a grid) 
        // We have 2 different types of objects and 3 of each type so 2 rows and 3 columns
        // You can set it to whatever values you want. If there are less cells than what you populate it with then there will be weird results
        // As long as there are more than 6 cells its all good
        centerPanel.setLayout(new GridLayout(2, 3));

        // Adds all our labels and text fields to the panel
        centerPanel.add(a);
        centerPanel.add(e);
        centerPanel.add(b);
        centerPanel.add(f);
        centerPanel.add(c);
        centerPanel.add(g);

        JFrame frame = new JFrame();

        // Tells the Frame what the close button does (The X button next to the minimize button at the top right of the frame)
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Adds the panel to the centre of the frame (BorderLayout.CENTER is the default layout mode)
        frame.add(centerPanel, BorderLayout.CENTER);

        // Adds a button to the bottom of the frame
        frame.add(new JButton("Do Button"), BorderLayout.SOUTH);

        // ALWAYS REMEMBER TO ADD THIS. Displays the frame
        frame.setVisible(true);
    }
}
```

  

## Question 9

### Answer

*   In this question, no error occurs and it executes the Try block and then proceeds to print "Done"

### Thoughts

1. _Executes the Try block line by line. If an error/exceptions occurs in a Try block then it will_ **_not_** _throw the exception and exit the Try block and enter the Catch block. It will then execute whatever is in the Catch block._
2. _If no error occurs in the Try block then everything would have been executed in the Try block and the code will continue_

  

## Question 10

```java
package Streams;

import java.io.IOException;
import java.io.RandomAccessFile;

public class ReadFile
{
    public String readFileString(RandomAccessFile file, int n, int m) throws IOException
    {
        // The string to store all the characters we find
        String resultString = "";

        // Tells the file to go to the character at position m
        file.seek(m);

        // Iterates from 0 until n
        // Since we told the file to go to position m. the Character at position m + 0 is m and we read from m until m + n 
        for (int i = 0; i < n; i++)
        {
            // Reads the character at position m + i
            // The file will read the next character and then go to that character's position in the file so that when we call readChar again we will read the next character
            resultString = resultString + file.readChar();
        }

        // Returns all the characters we found
        return resultString;
    }
}
```