## Concepts in depth
%% Begin Waypoint %%
- [[Abstract Data Types]]
- [[Advanced Data Structures]]
- [[Algorithm Analysis]]
- [[Data Structures]]
- [[Divide and Conquer]]
- [[Dynamic programming]]
- [[Graphs]]
- [[Greedy Algorithms]]
- [[Hashing]]
- [[Sorting Algorithms]]

%% End Waypoint %%
## Table of contents
```table-of-contents
```
## Core topics
#### Core Concepts in Dynamic Programming:
1. **Understanding Dynamic Programming**:
   - Principles of optimal substructure and overlapping subproblems.
   - The methodological approach to dynamic programming: identifying subproblems, memoization vs. tabulation, constructing DP solutions.

2. **Problem Solving with Dynamic Programming**:
   - Solving the knapsack problem: Understanding problem statement, simple vs dynamic programming approach, constructing and filling the DP table.
   - Longest Common Subsequence (LCS) and Longest Common Substring: Problem statement, dynamic programming solution, implementation details.
   - Real-world applications of dynamic programming: Bioinformatics (DNA sequence analysis), version control systems (diff tools), text processing, and word wrap algorithms.

#### Object-Oriented Programming (OOP) Principles Related to ADTs:
- Encapsulation, inheritance, polymorphism: their roles in creating [[Abstract Data Types]] (ADTs).
- Designing and implementing classes for ADTs using OOP principles.
- The distinction between ADTs and concrete implementations.
#### Data Structures:
- **Lists**: Concepts of linear data structures, array vs linked lists, singly and doubly linked lists, their complexities.
- **Stacks and Queues**: Understanding, implementing, and the complexities of basic operations.
- **Sets**: Differences between sets and lists, basic set operations, and their complexities.
- **Trees**: Types of trees (binary, BSTs, balanced, general), basic operations, and their applications.
#### Algorithm Analysis:
- Fundamental concepts including big-O notation, time complexity.
- Analyzing the efficiency of algorithms, understanding common complexity classes.
- Worst-case, average-case, and best-case scenarios.
#### Hashing:
- Dictionary ADT, hashing and hash tables, collision resolution techniques.
- Performance analysis of hash tables, hash function trade-offs.
#### Sorting Algorithms:
- Concepts including stability, in-place, and comparison-based sorting.
- Implementing and analyzing sorting algorithms, understanding their complexities.
- Sorting in linear time and with limited memory.
#### Graphs:
- Graph data structure fundamentals, types of graphs, representations, and basic operations.
- Graph traversal algorithms (DFS, BFS), shortest path algorithms (e.g., Dijkstra's), and graph theory.
#### Advanced Data Structures:
- **Tries**: Basic concepts, prefix tries, compression, implementation, and applications.
- **String Algorithms**: Pattern matching algorithms (brute-force, KMP, Boyer-Moore), their complexities, and use cases.
#### Algorithmic Methods:
- **Greedy Algorithms vs Dynamic Programming**: Understanding both, identifying when to use each.
- **Divide-and-Conquer**: Concepts, breaking down problems, recursion in divide-and-conquer algorithms, merge step, and base case identification.
#### Practical Application and Implementation:
- Implementing dynamic programming, greedy, divide-and-conquer, and sorting algorithms in real-world applications, and explaining their performance.
## Main exam topics
Based on the analysis of past exam papers from the Data Structures and Algorithms (DSA) course, here is a concise, comprehensive list of topics, types of questions, and skills needed to excel in your exam, ordered by importance and frequency of appearance:
#### Algorithm Analysis and Design
- **Big-O Notation and Complexity Analysis**: Understand and derive the time and space complexity of algorithms.
    - *Example Question*: Provide the big-O complexity of an algorithm that removes duplicates from an array.
- **Sorting Algorithms**: Knowledge of mergesort, quicksort, and their operations.
    - *Example Question*: Illustrate the operation of mergesort/quicksort on a given input.
- **Graphs**: Understanding of graph representations (adjacency list, adjacency matrix), properties, and traversals.
    - *Example Question*: Compare the space complexity of storing graphs as adjacency lists vs. adjacency matrices for various graph types.
- **Dynamic Programming**: Ability to solve optimization problems using DP.
    - *Example Question*: Design a dynamic programming solution for a given problem.
#### Data Structures
- **Trees and Binary Search Trees (BST)**: Operations, traversals, and modifications.
    - *Example Question*: Describe a procedure to delete a node from a binary search tree.
- **Tries**: Construction and compression, applications in spell-checking and autocomplete.
    - *Example Question*: Construct and compress a trie for a given set of strings.
- **Hash Tables**: Usage, implementation, and collision resolution techniques.
    - *Example Question*: Design an algorithm using a hash table to solve a problem.
- **Heaps**: Understanding heap operations and their application in sorting and priority queues.
    - *Example Question*: Draw the heap resulting from a series of insertions.
#### Advanced Topics
- **Graph Algorithms**: Shortest paths, tree traversals, and sorting for graphs without cycles.
    - *Example Question*: If all edge weights are equal, to what algorithm is Dijkstra's algorithm equivalent?
- **Disjoint Sets and Array Manipulation**: Algorithms to determine if two arrays are disjoint or to calculate the sum of the largest 'k' numbers.
    - *Example Question*: Design an algorithm that checks if two arrays are disjoint.
#### Practical Coding and Problem-Solving Skills
- Ability to express solutions in pseudo-code or simplified Java code, focusing on correctness, use of data structures, efficiency, and complexity analysis.
- Developing algorithms for specific problems and explaining your approach clearly.
- Writing code that is readable, with clear and descriptive naming for variables and functions.